/*******************************************************************************
* AntiballisticMissile class    
* An object for representing the player's missile generated by clicking the left
* mouse button. Used to destroy Enemy Missiles.
*******************************************************************************/
public class AntiballisticMissile {
  
  // fields
  private PVector currPos, targetPos, velocity;
  private boolean exploding, expended;
  private float explosionRadius, speed, angle;
  private int explosionFrame, explosionBegin;

  /* Constructor
  *  Parameter:
  *    PVector - the missile's target, which is passed in as the
  *              location of the cursor.
  */
  public AntiballisticMissile(PVector targetPos) {
    this.currPos = new PVector(width*0.5, height*0.77);
    this.targetPos = targetPos; // pass in where user clicked
    this.exploding = false;
    this.expended = false;
    this.explosionRadius = bulletRadius;
    this.velocity = PVector.sub(this.targetPos, this.currPos).normalize();
    this.speed = 35 / (targetFrameRate / 30f);
    this.explosionFrame = 0;
    this.angle = this.velocity.heading();
    
    // sound
    fireAbm.play();
  }
  
  // eithers updates the position, or when the missile is expoding,
  // updates the frame
  public void update() {
    if (this.expended) {
      return;
    }

    if (this.exploding) {
      this.explode();
      return;
    }

    this.advance();
  }
  
  // animates the explosion, changes state to expended once done 
  public void explode() {
    // Proceed to next image in animation every 1/10s
    if ((frameCount - this.explosionBegin) % (targetFrameRate / 7f) < 1) {
      this.explosionFrame++;
      
      // For collision detection
      float radiusChange = width * 7 / 1920f;
      if (frameCount - this.explosionBegin < targetFrameRate) {
        this.explosionRadius += radiusChange;
      } else {
        this.explosionRadius -= radiusChange;
      }
    }
    
    if (this.explosionFrame == abmExplosionFrames) {
      this.expended = true;
      return;
    }

    imageMode(CENTER);
    image(abmExplosion[this.explosionFrame], this.currPos.x, this.currPos.y);
  }

  // moves the missile towards its target, and if it has reached it,
  // detonates the missile
  public void advance() {
    // Advance towards target by a factor of speed
    this.currPos.add(PVector.mult(this.velocity, this.speed));

    // Check for arrival at target position
    // Must check less than or equal to speed as may overshoot
    if (PVector.dist(this.currPos, this.targetPos) <= this.speed) {
      // Copy the targetPos PVector object rather than
      // assigning currPos to targetPos in memory
      this.currPos = this.targetPos.copy();
      this.detonate();
    }
  }

  // draws the missiles at its current position, if it is not yet
  // exploding.
  public void draw() {
    // Do not display if expended
    if (this.expended) {
      return;
    }

    if (!this.exploding) { // Only draw if not exploding
      // Set colours and shape mode
      shapeMode(CORNER);
      missileShape.setFill(143);
      // Move to current position
      missileShape.translate(this.currPos.x, this.currPos.y);

      // Rotate towards target (add 90 degrees to take into account the
      // initial orientation of ellipse shape)
      missileShape.rotate(radians(90) + this.angle);

      // Draw shape
      shape(missileShape);

      // Reset shape before next frame
      missileShape.resetMatrix();
    }
  }
  
  // converts the state of the missile from travelling to target to
  // exploding
  public void detonate() {
    this.exploding = true;
    this.explosionBegin = frameCount;
    detonateAbm.play();
  }
  
  // detects collision between missiles and a PVector. 
  public boolean detectCollision(PVector em) {
    // Collision cannot occur if destroyed or not detonated
    if (this.expended || !this.exploding) {
      return false;
    }

    // Collision occurs if distance between current position and enemy missile
    // is less than current explosion radius
    return PVector.dist(this.currPos, em) <= this.explosionRadius;
  }

  public boolean isExpended() {
    return this.expended;
  }
  
  public PVector getCurrPos() {
    return this.currPos;
  }
}
